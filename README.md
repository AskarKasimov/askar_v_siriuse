# Решения заданий НТО ИБ 2023 от команды аскар_в_сириусе
## Блок 1 — CTF
### WEB 1
Поиск путей на сайте через утилиты по типу **dirb** результатов не дал.

Однако анализ клиентских **JS**-скриптов показал, что сайт турфирмы для уточнения цены поездки использует подключение по **WebSokcet**, отправляя при нажатии кнопки зашифрованные данные о выбранных пунктах в формате **JSON**.

Расшифровка даётся легко, ведь дешифрующий код находится в тех же скриптах с интуитивно понятными названиями функций.

Анализ отправки валидных данных на **WebSocket** по указанному в скриптах адресу дал понять, что сервер не оперирует никакими базами данных, и **SQL**-инъекции здесь бесполезны. Также было выявлено, что элементы поля *countries* никак не обрабатываются (в отличие от *startdate* и *enddate*), решает лишь их количество.

Заметим, что для десериализации **JSON** в скриптах используется стандартный метод **JSON.parse()**, который, как известно, с таким же успехом способен обрабатывать **XML**. Заменив поле *format* с **JSON** на **XML**, можно с лёгкостью написать **XML**-инъекцию в поле *data*, позволяющую прочитать файл с сервера:

```
<!DOCTYPE foo [ <!ENTITY injection SYSTEM "file:///flag.txt"> ]><countries>&injection;</countries><enddate/><startdate/><resttype/>
```
Флаг: *

### WEB 2
Обратившись к данным к задаче исходникам, можно заметить, что при запросе от *service1* к *service2* можно легко сделать **HTTP**-инъекцию, вписав её в поле *username*.

Сначала было решено попытаться редактировать **Cookie**, затем писать сразу два запроса, указывая собственный хост. Ничего из перечисленного не сработало.

Всячески перебирая различные известные нам способы **HTTP**-инъекций на локальном хосте, мы заметили, что при неправильном составлении запроса вся строка печатается на экране. Добиться такого результата можно, например, вписав одиночный `\r` символ.

Данная уязвимость и была использована на удалённом сервере.

Флаг: *
