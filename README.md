# Решения заданий НТО ИБ 2023 команды аскар_в_сириусе
# CTF

### WEB 1

Поиск путей на сайте через утилиты по типу `dirb` результатов не дал.

Однако анализ клиентских `JS`-скриптов показал, что сайт турфирмы для уточнения цены поездки использует подключение по `WebSokcet`, отправляя при нажатии кнопки зашифрованные данные о выбранных пунктах в формате `JSON`.

Расшифровка даётся легко, ведь дешифрующий код находится в тех же скриптах с интуитивно понятными названиями функций.

Анализ отправки валидных данных на `WebSocket` по указанному в скриптах адресу дал понять, что сервер не оперирует никакими базами данных, и `SQL`-инъекции здесь бесполезны. Также было выявлено, что элементы поля `countries` никак не обрабатываются (в отличие от `startdate` и `enddate`), решает лишь их количество.

Заметим, что для десериализации `JSON` в скриптах используется стандартный метод `JSON.parse()`, который, как известно, с таким же успехом способен обрабатывать `XML`. Заменив поле `format` с `JSON` на `XML`, можно с лёгкостью написать `XML`-инъекцию в поле *data*, позволяющую прочитать файл с сервера:

```
<!--?xml version='1.0' ?--><!DOCTYPE replace [<!ENTITY ent SYSTEM 'file:///flag.txt'> ]><data><countries>&ent;</countries><startdate></startdate><enddate></enddate><resttype></resttype></data>
```

Флаг: nto{w3bs0ck3ts_plu5_xx3_1s_l0v3}

### WEB 2

Обратившись к данным к задаче исходникам, можно заметить, что при запросе от *service1* к *service2* можно легко сделать `HTTP`-инъекцию, вписав её в поле *username*.

Сначала было решено попытаться редактировать `Cookie`, затем писать сразу два запроса, указывая собственный хост. Ничего из перечисленного конечно не сработало.

Всячески перебирая различные известные нам способы `HTTP`-инъекций на локальном хосте, мы заметили, что при неправильном составлении запроса вся строка печатается на экране. Добиться такого результата можно, например, вписав одиночный `\r` символ.

Данная уязвимость и была использована на удалённом сервере.

![https://i.imgur.com/vRgBzgG.png](https://i.imgur.com/vRgBzgG.png)

Флаг: NTO{request_smuggling_917a34072663f9c8beea3b45e8f129c5}

### WEB 3

Осмотрев данные к задаче исходники, можно сразу же заметить весьма популярную уязвимость `Prototype Pollution`, исполняемую на эндпоинте `/pollute`.

Данная уязвимость позволяет менять так называемые *прототипы* в `JavaScript`, чем мы и воспользовались.

Можно заметить, что для получения доступа к эндпоинтам под `/admin` идёт проверка `IP` пользователя на локальный. Используя разведанную уязвимость, можно перезаписать необходимое поле:

```
/pollute/_userProperty/isLocalRequest
```

После этого нужно авторизоваться в корне сайта и пройти на `/admin/flag`

Флаг: nto{pr0t0typ3_pollut10n_g4dged5_f56acc00f5eb803de88496b}

### REVERSE 1

При запуске файла флаг сам печатается в консоль, но временной промежуток между появлением каждого символа увеличивается в прогрессии.

Открыв данный файл с помощью `Ghidra`, мы заметили цикл `for`, который каждую итерацию увеличивал переменную.

Заменив инструкцию `INT` на `NOP`, временные промежутки перестали расти, и флаг проявился мнгновенно.

Флаг: -

### CRYPTO 1

В данной задаче для шифрования использовались диэдральные группы. Затем символы флага шифровались путём замены символа на соответствующий ему элемент группы.

Уязвимость заключается в том, что для генерации группы использовались одни и те же входные данные, что приводило к генерации идентичных групп при каждом запуске.

Таким образом, флаг можно получить, составив карту всех символов ASCII и соответствующих им элементов группы. После этого для расшифровывания достаточно лишь узнать, какому символу соответствует тот или иной элемент группы.

Флаг: `nto{5tr4ng3_gr0up_5tr4ng3_l0g_and_depressed_kid_zxc_ghoul}`

### CRYPTO 2

Путем подбора значения в `GET` запрос, мы определили, что длина исходной строки - 135 символов.

Поскольку в исходном коде условием, отличающим 1 от 0, было то, что получаемое значение меньше `n // 2`, а в ответ на одно значение в `GET` запрос сервер выдавал разные значения, мы решили написать скрипт на `Python`, который бы присваивал 1 по индексу элемента, если хотя бы в одной строке этот элемент принимал значение, удовлетворяющее нашему условию.

Получившийся список мы затем перевели в строку и перевели в шестнадцатиричную систему счисления, а из нее - в массив байтов. Массив байтов мы перевели в текст и вывели.

```python
import requests

n = 76855837862271564579909916281104430778664547916110050949680815562172600053428489920125005955660483692300119473167199398238398031483701199186798126652106290443776214539999741085740776693706366480534626541140704843679109999662521747087925673035432553331712468721503398592522039548079563635224655997820326328541
URL = "http://10.10.3.10:1177/guess_bit"
my_list = ['0'] * 135

for j in range(10):
	for i in range(135):
		PARAMS = {'bit':i}
		r = requests.get(url = URL, params = PARAMS)
		data = r.json()
		if data['guess'] < n // 2:
			my_list[i] = '1'

answer = ''.join(my_list)
answer_to_hex = hex(int(answer,2))[2:]
byte_answer = bytearray.fromhex(answer_to_hex)

print(byte_answer.decode())
```

Флаг: nto{0h_n0_t1m1ng}

# Forensics №1

1. В `/home/sergey` находится файл `minecraft.jar`. Судя по легенде, это и есть вредоносный софт. Разобрав `.jar` в онлайн-декомпиляторе, можно сразу увидеть `package Malware` с лежащим внутри `ReverseShell.java`. Его содержимое сразу даёт понять, что благодаря программе было открыто соединение на `Socket`, дающее подключенному к хосту устройству доступ к `/usr/bin/bash`.
    
    ![https://i.imgur.com/ZgSJR9Q.png](https://i.imgur.com/ZgSJR9Q.png)
    
2. После получения доступа к машине злоумышленник загрузил и запустил скрипт `linpeas`, который автоматически просканировал систему на наличие уязвимостей. Сканирование показало, что у программы `find` установлен бит `SUID`, позволяющий запускать программу с правами владельца. Владелец `find` - `root`.
    
    ![https://i.imgur.com/f5coZUy.png](https://i.imgur.com/f5coZUy.png)
    
    Для повышения прав доступа злоумышленнику нужно было лишь выполнить эту команду после чего он получил доступ к `root`:`./find . -exec /bin/sh -p \; -quit`
    
3. Зайдя на устройство пользователя, злоумышленник поставил утилиту `logkeys`, позволяющую отслеживать все нажатые жертвой клавиши. Именно так атакующий и отследил ввод пароля пользователем.
4. У нас появилось предположение, что логи `logkeys` лежат там же, где обычно лежат логи прочих программ, то есть `/var/log`, ведь при запуске программы (из `.bash_history` видно, что никаких дополнительных параметров для вывода логов хакером введено не было). Зайдя в предполагаемую директорию находим файл `logkeys.log`, вероятно, с нужными нам логами:
    
    ![https://i.imgur.com/7huR9Fv.png](https://i.imgur.com/7huR9Fv.png)
    
    Чтобы проверить это наверняка, запускаем программу параллельно с утилитой `tail`, которая позволяет видеть изменения файлов в реальном времени:
    
    ![https://i.imgur.com/MHdJzzB.png](https://i.imgur.com/MHdJzzB.png)
    
5. В файле `passwords.kdbx` лежат данные для входа на **RDP Windows**:
    - логин: `Administrator`
    - пароль: `SecretP@ssw0rdMayby_0rNot`
